## 삽입 정렬

<br>

<img src="../_assets/insertion-sort.gif" width="500" />

<br>

**"insertion sort"**

정렬되지 않은 데이터를 하나씩 꺼내어 이미 정렬된 부분의 올바른 위치에 "삽입"하기 때문에 삽입 정렬이다.

<br>

### 삽입 정렬의 과정

1. 첫 번째 요소는 이미 정렬되었다고 가정하고, 두 번째 요소부터 시작한다.
2. 현재 요소를 정렬된 부분에서 적절한 위치를 찾아 삽입한다.
3. 이 과정을 모든 요소에 대해 반복하면서 정렬을 완성한다.

<br>

### 예시

```
[8, 5, 3, 2, 6, 9, 7, 4, 1]
```

| 단계  | 정렬된 부분 | 삽입할 값 | 결과 |
|------|------------|----------|-----------------|
| 1단계 | `[8]` | `5` | `5, 8, 3, 2, 6, 9, 7, 4, 1` |
| 2단계 | `[5, 8]` | `3` | `3, 5, 8, 2, 6, 9, 7, 4, 1` |
| 3단계 | `[3, 5, 8]` | `2` | `2, 3, 5, 8, 6, 9, 7, 4, 1` |
| 4단계 | `[2, 3, 5, 8]` | `6` | `2, 3, 5, 6, 8, 9, 7, 4, 1` |
| 5단계 | `[2, 3, 5, 6, 8]` | `9` | `2, 3, 5, 6, 8, 9, 7, 4, 1` |
| 6단계 | `[2, 3, 5, 6, 8, 9]` | `7` | `2, 3, 5, 6, 7, 8, 9, 4, 1` |
| 7단계 | `[2, 3, 5, 6, 7, 8, 9]` | `4` | `2, 3, 4, 5, 6, 7, 8, 9, 1` |
| 8단계 | `[2, 3, 4, 5, 6, 7, 8, 9]` | `1` | `1, 2, 3, 4, 5, 6, 7, 8, 9` |

최종 정렬된 배열 > `1, 2, 3, 4, 5, 6, 7, 8, 9`

<br>

### 삽입 정렬의 시간 복잡도

삽입 정렬의 시간 복잡도는 **입력 데이터의 정렬 상태에 따라 달라진다**.

#### 최악 (Worst Case): **O(𝑁²)**
- **입력이 내림차순(완전히 정렬되지 않은 상태)일 때**
- 각 요소를 삽입할 때마다 정렬된 부분을 **끝까지 탐색**해야 하므로 비교 및 이동 연산이 최대가 된다.
- **예시**  

  ```9, 8, 7, 6, 5, 4, 3, 2, 1```

- **총 비교 횟수**  

    1. `8 삽입` → 9과 비교 (1번)
    2. `7 삽입` → 8, 9과 비교 (2번)
    3. `6 삽입` → 7, 8, 9과 비교 (3번)
    4. `5 삽입` → 6, 7, 8, 9과 비교 (4번)
    5. `4 삽입` → 5, 6, 7, 8, 9과 비교 (5번)
    6. `3 삽입` → 4, 5, 6, 7, 8, 9과 비교 (6번)
    7. `2 삽입` → 3, 4, 5, 6, 7, 8, 9과 비교 (7번)
    8. `1 삽입` → 2, 3, 4, 5, 6, 7, 8, 9과 비교 (8번)
    - 총 1 + 2 + 3 + ... + (N-1) 번으로 여기서는 36번 비교 수행



- **일반화된 비교 횟수 공식**  

  ```(N-1)N / 2```



#### 최선 (Best Case): **O(𝑁)**
- **입력이 이미 정렬된 상태(오름차순)일 때**
- 각 요소가 이미 올바른 위치에 있어 **비교만 수행되고 이동할 필요가 없음**  
- 가장 오른쪽의 원소가 N-1번 만 비교 연산 후 종료

#### 평균 (Average Case): **O(𝑁²)**
- **무작위 데이터일 때**
- 평균적으로 한 요소가 정렬된 부분의 **절반 정도를 탐색**해야 함
- 대략적으로 최악과 최선의 중간 형태가 되어 **O(N²)로 수렴**

<br>

### 삽입 정렬의 특징
1. **거의 정렬된 데이터에서는 매우 효율적** (O(N))  
2. **제자리 정렬(In-place) → 추가 메모리 필요 없음**  
3. **안정 정렬(Stable Sort) → 같은 값의 순서가 유지됨**  
4. **큰 데이터셋에서는 비효율적** (O(N²) → 느림)  

<br>

### 공간 복잡도
- **O(1) (제자리 정렬, In-place Sort)**  
- 주어진 배열 내에서 요소를 이동시키면서 정렬하므로 **추가적인 메모리 사용이 거의 없다.**
- 삽입 과정에서 **임시 변수(temporary variable) 하나만 사용**하므로, 배열 크기 `N`에 관계없이 **추가 메모리는 상수 공간(O(1))** 만 필요하다.

<br>

### 정리

삽입 정렬은 **작은 배열**이거나 **거의 정렬된 데이터**에 대해 효율적이다.  
하지만 **큰 데이터셋에는 비효율적**이므로 **퀵 정렬(O(N log N))** 같은 다른 정렬 알고리즘을 사용하는 것이 좋다.