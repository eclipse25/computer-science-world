## BFS (너비 우선 탐색, Breadth-First Search)

<img src="../_assets/bfs-dfs.gif" width="500" />

<br>

- 그래프의 모든 노드를 방문하기 위한 알고리즘
- 루트 노드(혹은 다른 임의의 노드)에서 시작하여 인접한 모든 노드를 먼저 탐색한다.
- 큐(Queue)를 사용하여 구현할 수 있으며, 이는 각 노드를 방문할 때마다 해당 노드와 인접한 노드를 큐에 추가하고, 큐에서 노드를 하나씩 꺼내어 그 노드의 인접 노드를 탐색하는 방식으로 진행된다.

<br>

### BFS 알고리즘의 기본 절차

1. 노드 방문: 시작 노드를 큐에 삽입하고 방문 처리한다.
2. 인접 노드 탐색: 큐에서 노드를 하나 꺼내어 그 노드의 인접 노드를 모두 확인한다. 방문하지 않은 인접 노드를 모두 큐에 삽입하고 방문 처리한다.
3. 탐색 반복: 큐가 비어있을 때까지 이전 과정을 반복한다.
4. 모든 노드 방문 완료: 큐가 비어있으면 탐색을 종료한다.

<br>

### BFS 알고리즘 구현 예시 - Queue (Python)

다음 코드는 시작 노드 'A'부터 BFS 방식으로 그래프를 탐색하고, 방문한 노드를 출력한다. deque를 사용하여 큐를 구현하고, 방문하지 않은 인접 노드를 순서대로 큐에 추가함으로써 너비 우선 탐색을 진행한다. 이 방식은 각 레벨의 모든 노드를 탐색한 후 다음 레벨의 노드를 탐색하는 방식으로, 가장 가까운 노드부터 차례대로 탐색한다.

```python
from collections import deque

# BFS 알고리즘 구현
def bfs(graph, start_node):
    # 방문한 노드를 저장할 집합
    visited = set()
    # BFS를 위한 큐, 시작 노드를 포함하여 초기화
    queue = deque([start_node])

    # 큐가 비어있지 않는 동안 반복
    while queue:
        # 큐에서 하나의 노드를 꺼냄
        node = queue.popleft()
        # 현재 노드를 방문하지 않았다면
        if node not in visited:
            # 방문 처리
            visited.add(node)
            print(node, end=' ')

            # 현재 노드에 인접한 노드 중 방문하지 않은 노드들을 큐에 추가
            queue.extend([x for x in graph[node] if x not in visited])

# 간단한 그래프 예시
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# 'A'에서 시작하는 BFS 실행
bfs(graph, 'A')
```

<br>

### 최단경로

- 최단 경로 탐색: BFS는 시작 노드로부터 가까운 노드부터 차례대로 탐색하기 때문에, 목표 노드에 도달했을 때 그 경로가 최단 경로임이 보장된다. 즉, BFS는 레벨별로 탐색하기 때문에 모든 가능한 경로 중 가장 짧은 경로를 찾아낼 수 있다.

- 효율성: DFS는 목표 노드를 찾기 위해 가능한 모든 경로를 탐색할 수 있으며, 이는 최단 경로를 찾는 문제에서 비효율적일 수 있다. DFS를 사용하면 길이 막힌 경로를 따라 깊숙이 탐색할 수 있으며, 결국에는 되돌아와 다른 경로를 탐색해야 할 수도 있다. 특히 큰 미로에서 많은 시간을 소비하게 될 수 있다.

- 경로 길이 계산: BFS는 시작점으로부터의 거리(즉, 경로 길이)를 자연스럽게 계산할 수 있다. 각 단계에서 모든 인접 노드는 이전 단계의 노드로부터 한 칸 더 멀리 있으므로, 탐색의 각 단계는 시작점으로부터의 거리에 대한 정보를 제공한다. 반면, DFS는 경로의 길이를 추적하기 위해 추가적인 처리가 필요할 수 있다.
