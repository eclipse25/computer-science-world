## 프로세스와 스레드

<br>

### 프로세스

- **프로세스**: 메모리에 적재되어 지금 실행 중인 프로그램  
- 작업 관리자에서 볼 수 있듯 동시에(사용자가 눈치채지 못하도록 빠르게 번갈아가며) 실행되는 프로세스는 매우 많다.  
- 다양한 프로세스를 관리하고 실행한다.  
- 프로세스와 스레드, 프로세스 동기화, 교착상태 해결 등을 수행한다.  

#### 종류

- **포그라운드 프로세스(foreground process)**: 사용자가 볼 수 있는 공간에서 실행되는 프로세스  
- **백그라운드 프로세스(background process)**: 사용자가 볼 수 없는 공간에서 실행되는 프로세스  
  - 백그라운드 프로세스에는 사용자와 상호작용이 가능한 프로세스와, 특정 기능만 수행하는 프로세스가 있다.  
  - 후자는 **유닉스 계열에서는 "데몬(daemon)", 윈도우에서는 "서비스(service)"**라고 한다.  
  - 데몬과 서비스는 시스템이 부팅될 때 자동 실행되며, 특정 작업을 백그라운드에서 지속적으로 수행한다.  

#### 프로세스 제어 블록(PCB)

- CPU 자원은 한정되어 있기 때문에 프로세스들은 돌아가며 한정된 시간만큼만 CPU를 이용한다.  
- 타이머 인터럽트(타임아웃 인터럽트)가 발생하여 시간이 끝났음을 알리면 차례를 양보한다.  
- **프로세스 제어 블록(PCB)**: 운영체제가 프로세스를 관리하기 위해 사용하는 자료구조로, 프로세스의 실행 상태를 저장하는 역할을 한다.  
- PCB에는 프로세스 관련 정보를 저장한다.  
  - 프로세스 ID(PID)  
  - 레지스터 값 → 이전의 작업을 이어 실행하기 위해 사용했던 레지스터의 중간값들을 모두 복원  
    - 프로그램 카운터(프로세스가 다음에 실행할 명령어의 주소)  
    - CPU 레지스터  
  - 프로세스 상태  
  - CPU 스케줄링 정보 → 어떤 프로세스를 먼저, 얼마나 오래 실행할지  
  - 메모리 정보  
  - 사용한 파일과 입출력 장치 정보  
- 프로세스 생성 시 커널 영역에 PCB를 생성하고, 종료 시 폐기한다.  

#### 문맥 교환(context switch)

- 한 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 기존에 실행되던 프로세스는 중간 정보들을 백업해야 한다.  
- **문맥(Context)**: 다음 차례가 왔을 때 실행을 재개하기 위한 정보  
  - 프로그램 카운터 등 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력 장치 등  
- **문맥 교환(Context switching)**: 프로세스 전환 시 기존에 실행 중인 프로세스의 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정  
- 문맥 교환이 빈번하게 발생하면 시스템 오버헤드가 증가하여 성능 저하를 초래할 수 있다.  

#### 프로세스의 메모리 영역

- 메모리의 사용자 영역은 다음 영역들과 기타 영역들로 나뉜다.  
- 일반적으로 커널은 가장 높은 주소에 할당되어 있고 그 다음 순서는 다음과 같다.  

1. **스택 영역(stack segment)**  
   - 데이터가 일시적으로 저장되는 공간  
   - 매개 변수, 지역 변수  
   - 크기가 변하는 동적 할당 영역  
2. **힙 영역(heap segment)**  
   - 프로그래머가 직접 할당할 수 있는 저장 공간  
   - **가비지 컬렉션(Garbage Collection)**: 프로그래밍 언어가 할당된 메모리 공간을 알아서 반환  
   - **메모리 누수(memory leak)**: 할당된 메모리 영역을 반환하지 않아 생기는 메모리 낭비(C언어)  
   - 크기가 변하는 동적 할당 영역  
3. **데이터 영역(data segment)**  
   - 프로그램이 실행되는 동안 유지할 데이터 저장  
   - 전역 변수  
   - 크기가 고정된 정적 할당 영역  
4. **코드 영역(code segment)**  
   - 텍스트 영역이라고도 한다.  
   - 실행할 수 있는 코드, 기계어로 이루어진 명령어를 저장한다.  
   - CPU가 실행할 명령어가 담긴 공간으로 쓰기가 금지되어 있다.  
   - 크기가 고정된 정적 할당 영역  

- 일반적으로 **스택(Stack)은 높은 주소에서 낮은 주소로**, **힙(Heap)은 낮은 주소에서 높은 주소로** 할당된다.  
- 하지만 이는 운영체제와 CPU 아키텍처에 따라 달라질 수 있으며, 스택과 힙이 서로 확장되다가 충돌하면 **스택 오버플로(stack overflow)** 또는 **힙 오버플로(heap overflow)**가 발생할 수 있다.  

<br>

### 스레드

- **스레드(thread)**: 실행 프로세스를 구성하는 실행 흐름의 단위  
  - 스레드 ID, 프로그램 카운터를 포함한 레지스터 값, 스택 등으로 구성됨.  
  - 실행에 필요한 최소한의 정보를 유지한 채 실행됨.  
  - 모든 스레드는 **프로세스의 자원을 공유**하며 실행됨.  
- 하나의 프로세스는 하나 이상의 스레드를 가질 수 있음.  
- **멀티 스레드 프로세스**: 실행 흐름이 여러 개인 프로세스  
  - 프로세스를 이루는 여러 명령어를 동시 실행 가능.  
- 리눅스에서는 프로세스와 스레드를 구분하지 않고 태스크(Task)라고 표현함.  

#### 커널 스레드 vs 사용자 스레드

- **커널 스레드(Kernel Thread)**: 운영체제가 직접 관리하는 스레드.
- **사용자 스레드(User Thread)**: 운영체제가 아닌 사용자 공간에서 실행되는 스레드.

#### 멀티 스레드 모델

- **1:1 모델(One-to-One)**: 하나의 사용자 스레드가 하나의 커널 스레드와 연결됨.
- **N:1 모델(Many-to-One)**: 여러 개의 사용자 스레드가 하나의 커널 스레드에 매핑됨.
- **M:N 모델(Many-to-Many)**: 여러 개의 사용자 스레드가 여러 개의 커널 스레드에 매핑됨.

#### 스레드 동기화(Thread Synchronization)

- 여러 개의 스레드가 공유 자원에 접근할 경우 **데이터 충돌**이 발생할 수 있음.
- 이를 해결하기 위한 동기화 기법:
  - **뮤텍스(Mutex)**: 한 번에 하나의 스레드만 실행 가능.
  - **세마포어(Semaphore)**: 한 번에 여러 개의 스레드가 접근 가능하지만 개수를 제한.
  - **조건 변수(Condition Variable)**: 특정 조건이 만족될 때까지 스레드 실행을 제어.

#### 스레드의 장점과 단점

- **장점**:
  - 프로세스보다 **메모리 공유가 용이**하여 자원 소모가 적음.
  - 프로세스 간 통신(IPC)보다 **스레드 간 통신이 빠름**.
  - **병렬 처리**가 가능하여 CPU 활용률이 증가함.

- **단점**:
  - **동기화 문제** 발생 가능 → 공유 자원 접근 시 데이터 충돌 가능.
  - 하나의 스레드가 예외(Exception)로 인해 종료되면 **전체 프로세스가 영향을 받을 수 있음**.
  - 문맥 교환(Context Switching) 비용이 존재함.

#### 스레드 풀(Thread Pool)

- 스레드 생성과 제거 비용을 절감하기 위해 **미리 생성된 스레드를 재사용**하는 방식.
- **장점**:
  - **스레드 생성 비용 절감**.
  - **최대 동시 실행 스레드 개수를 제한**하여 시스템 과부하 방지.
- Python의 `concurrent.futures.ThreadPoolExecutor`나 Java의 `ExecutorService` 등이 대표적인 구현.


<br>

### 멀티 프로세스와 멀티 스레드

1. **멀티 프로세스(Multi-Process)**  
   - 독립적인 여러 개의 프로세스를 실행하는 방식으로, 각 프로세스는 **자신만의 메모리 공간을 가지며, 자원을 공유하지 않는다**.  
   - 프로세스 간 통신(IPC)이 필요하며, 문맥 교환 비용이 크다.  
   - **안정성이 높지만, 성능 면에서 비효율적일 수 있다.**  

2. **멀티 스레드(Multi-Threading)**  
   - 하나의 프로세스 내에서 여러 개의 스레드를 실행하는 방식으로, **스레드끼리 메모리와 자원을 공유한다**.  
   - 자원 공유로 인해 프로세스 간 통신이 빠르고 협력 작업에 유리하다.  
   - 하지만 하나의 스레드가 충돌하면 전체 프로세스가 종료될 위험이 있다.  
