## HTTPS와 TLS 핸드셰이크

<br>

### **HTTPS (HyperText Transfer Protocol Secure)**

- HTTPS는 HTTP에 **SSL/TLS 암호화**를 추가한 보안 프로토콜이다.
- 데이터를 암호화하여 **기밀성(Confidentiality)** 과 **무결성(Integrity)** 을 보장한다.
- HTTPS는 서버의 신원을 인증하고, 사용자가 접속하려는 서버가 실제 의도한 서버임을 확인할 수 있도록 한다.

<br>

### **SSL vs TLS**

| 구분  | SSL (Secure Sockets Layer) | TLS (Transport Layer Security) |
|-------|----------------------------|--------------------------------|
| 보안  | 비교적 낮음                 | 강력한 암호화 및 보안 알고리즘 지원 |
| 해시  | MD5, SHA-1 사용             | SHA-256 이상 지원              |
| 공격 취약성 | POODLE 공격에 취약 | 보안 취약점 개선               |
| 최신 버전 | SSL 3.0 (더 이상 사용되지 않음) | TLS 1.3 (현재 최신 표준) |

<br>

### **HTTPS 연결 과정**

#### 1. **인증서 발급 과정**
- 웹 서버 운영자는 **CA(Certificate Authority, 인증기관)** 에 인증서 발급 요청.
- CA는 요청을 검증한 후 디지털 인증서를 발급.
- 클라이언트(웹 브라우저)는 서버가 제공하는 인증서를 검증하여 신뢰성을 확보.

#### 2. **TLS Handshake (핸드셰이크 과정)**
TLS 핸드셰이크는 클라이언트와 서버가 보안 연결을 설정하는 과정으로, 주요 단계는 다음과 같다.

1. **Client Hello**
   - 클라이언트가 서버에 지원하는 TLS 버전, 암호화 알고리즘, 난수 값을 전송.
   
2. **Server Hello**
   - 서버가 클라이언트가 지원하는 옵션 중에서 하나를 선택하고, 난수 값을 전송.
   
3. **Server Certificate**
   - 서버가 자신의 **SSL/TLS 인증서**를 클라이언트에게 전송하여 신원을 확인.
   
4. **Client Key Exchange**
   - 클라이언트는 **Pre-Master Secret**을 생성하고, 서버의 공개키로 암호화하여 서버에 전송.
   
5. **Master Key 생성**
   - 클라이언트와 서버는 난수를 기반으로 **대칭키(Symmetric Key)** 를 생성하여 데이터를 암호화.
   
6. **Change Cipher Spec**
   - 클라이언트와 서버는 "암호화된 통신을 시작하겠다"는 신호를 교환.
   
7. **Finished 메시지 전송**
   - 서로 암호화된 메시지를 주고받으며 핸드셰이크 과정 완료.

<br>

### **TLS의 주요 개선점 (SSL → TLS)**

| 개선 사항 | 설명 |
|-----------|------------------------------------------------------|
| 더 강력한 암호화 | TLS 1.2 이상에서는 AES 및 SHA-256과 같은 강력한 알고리즘 지원 |
| 보안 취약점 해결 | SSL 3.0의 POODLE 공격 방어, 암호화된 알림 메시지 추가 |
| 성능 개선 | TLS 1.3에서 핸드셰이크 단계를 줄여 속도 향상 |
| 세션 재개 | 세션 티켓을 사용하여 재연결 시 핸드셰이크 과정 단축 |

<br>

### **정리**
HTTPS는 HTTP의 보안성을 강화한 프로토콜이며, TLS는 SSL의 발전된 버전으로 **더 강력한 보안과 성능 개선을 제공한다.**
TLS 핸드셰이크는 클라이언트와 서버 간의 안전한 연결을 구축하는 핵심 과정으로, HTTPS 보안의 기반이 된다.

